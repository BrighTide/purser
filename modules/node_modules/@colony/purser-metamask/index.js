/* @flow */

import MetamaskWallet from './class';
import {
  methodCaller,
  getInpageProvider,
  detect as detectHelper,
} from './helpers';

import { staticMethods as messages } from './messages';

import type { MetamaskInpageProviderType } from './flowtypes';

/**
 * Open the Metamask Wallet instance
 *
 * @method open
 *
 * @return {WalletType} The wallet object resulted by instantiating the class
 * (Object is wrapped in a promise).
 */
export const open = async (): Promise<MetamaskWallet> =>
  /*
   * @TODO Check if the new version if available
   * @TODO Inject the web3 instance
   * @TODO Enable
   * @TODO Catch if enable was rejected
   * @TODO If we're not on the new version, warn about being in legacy mode
   */
  methodCaller(() => {
    const {
      publicConfigStore: { _state: state },
    }: MetamaskInpageProviderType = getInpageProvider();
    return new MetamaskWallet({
      address: state.selectedAddress,
    });
  }, messages.metamaskNotAvailable);

/**
 * Check if Metamask's injected web3 proxy instance is available in the
 * global object.
 *
 * Makes use of the `detect()` helper, basically it's a wrapper
 * that exposes it from the module.
 *
 * @method detect
 *
 * @return {boolean} Only returns true if it's available, otherwise it will throw.
 */
export const detect = async (): Promise<boolean> => detectHelper();

/*
 * @NOTE There's an argument here to expose the new version
 */

const metamaskWallet: Object = {
  open,
  detect,
};

export default metamaskWallet;
