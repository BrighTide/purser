/* @flow */

import Web3Instance from 'web3';

import MetamaskWallet from './class';
import {
  methodCaller,
  getInpageProvider,
  detect as detectHelper,
} from './helpers';

import { staticMethods as messages } from './messages';

import type { MetamaskInpageProviderType } from './flowtypes';

/**
 * Open the Metamask Wallet instance
 *
 * @method open
 *
 * @return {WalletType} The wallet object resulted by instantiating the class
 * (Object is wrapped in a promise).
 */
export const open = async (): Promise<MetamaskWallet> => {
  try {
    /*
     * We're on the Modern Metamask (after EIP-1022)
     * See: https://eips.ethereum.org/EIPS/eip-1102
     */
    if (global.ethereum) {
      /*
       * Enable it
       */
      await global.ethereum.enable();
      /*
       * Inject the web3 provider
       */
      global.web3 = new Web3Instance(global.ethereum);
    }
    /*
     * We're on the legacy version of Metamask
     */
    if (global.web3) {
      /*
       * @TODO Warn the user the we're running in legacy mode
       *
       * Enable it
       *
       * @NOTE There's an argument to be made here that it's dangerous to use
       * the `getInpageProvider()` helper before using `detect()`
       */
      const legacyProvider: MetamaskInpageProviderType = getInpageProvider();
      legacyProvider.enable();
      /*
       * Inject the web3 provider (overwrite the current one)
       */
      global.web3 = new Web3Instance(legacyProvider);
    }
    /*
     * Everything goes one as previous since the Web3 instance is now in place
     * (Granted, it's now using the 1.x.x version)
     */
    return methodCaller(() => {
      const {
        publicConfigStore: { _state: state },
      }: MetamaskInpageProviderType = getInpageProvider();
      return new MetamaskWallet({
        address: state.selectedAddress,
      });
    }, messages.metamaskNotAvailable);
  } catch (caughtError) {
    /*
     * User did not authorize us to open his account. We cannot do anything else.
     * (By clicking the 'Reject' button on the API request popup)
     */
    throw new Error(messages.didNotAuthorize);
  }
};

/**
 * Check if Metamask's injected web3 proxy instance is available in the
 * global object.
 *
 * Makes use of the `detect()` helper, basically it's a wrapper
 * that exposes it from the module.
 *
 * @method detect
 *
 * @return {boolean} Only returns true if it's available, otherwise it will throw.
 */
export const detect = async (): Promise<boolean> => detectHelper();

/*
 * @NOTE There's an argument here to expose the new version
 */

const metamaskWallet: Object = {
  open,
  detect,
};

export default metamaskWallet;
